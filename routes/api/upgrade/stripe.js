const router = require('express').Router()
const bodyParser = require('body-parser');
var stripe = require("stripe")(process.env.STRIPE_PRIVATE_KEY)
const mongoose = require('mongoose')

const other = require('../../../my_modules/other')
const mailgun = require('../../../my_modules/email')
const accountAPI = require('../../../my_modules/accountapi')

const ForumSettings = mongoose.model("ForumSettings")
const Accounts = mongoose.model("Accounts")

var webhookSecret = process.env.STRIPE_WEBHOOK_PRIVATE_KEY
var juniorPlanID = process.env.STRIPE_PREMIUM_PLAN_ID

// 	/api/stripe

router.use((req, res, next) => {
	if(!process.env.STRIPE_PREMIUM_PLAN_ID) return res.render("400", {reason: "Stripe has not been configured"})
	else next()
})

//Create subscription for Junior patronage
router.use('/subscribe', bodyParser.urlencoded({ extended: false }))
router.use('/subscribe', bodyParser.json({limit: '5mb'}))
router.post('/subscribe', async (req, res, next) => {
	try {
		let response = {success:false}

		let uid = req.session.uid
		if(!uid) throw "Not logged in"
		
		//Get account data
		let accInfo = await Accounts.findById(uid).lean()
		if(!accInfo) throw "Failed to retrieve your account"
		accInfo.roles = other.StringToArray(accInfo.roles)
		
		//Check if user already has the patron role
		if(accInfo.roles.indexOf("patron") != -1) throw "You're already a Patron!"
		
		//Check if user already has a pending purchase
		if(accInfo.stripecustomerid == "pending") throw "It looks like a purchase is already initiated. Please return and wait for the server to process it!"

		//Email verification check
		if(!await accountAPI.emailVerified(uid)) throw "Please verify your email first"

		/* 
		
		!!  You should check if the person has already purchased !! 
		
		Logic: 
		Get list of customers with the metadata uid corresponding to client's uid
			-Make sure the customer isnt a deleted customer
		Check each retrieved customer to see if theyve subscribed to the plan
		Cancel and refund any extra customers. There should only be one per account
		
		*/
		
		//Create new customer
		var customer = await stripe.customers.create({
			email: accInfo.email,
			description: 'Junior patronage',
			metadata: {uid: accInfo._id}, //This is only assigned so I can use Stripe's search bar
			source: req.body.stripeToken //generated by stripe api on client side
		})

		//Successfully created new customer
		
		//Mark as pending purchase to prevent double purchasing
		//Note that if crashes before pending mark is removed, the account will remain listed as pending, thus will never be able to purchase junior.
		//On that note, be sure to keep the code flawless
		await Accounts.updateOne({_id: uid}, {stripecustomerid: "pending"})
		.catch(()=>{console.warn("Failed to mark customer pending purchaser for stripe")})
		
		//Create subscription and press charge
		await stripe.subscriptions.create({
			customer: customer.id,
			metadata: {uid: accInfo._id},
			items: [{plan: juniorPlanID}]
		})
		.catch(async err => {
			//User failed to charge: Such as when card rejected or card expired
			//Mark user as no longer attempting purchase. It is important that this doesn't fail!
			await Accounts.updateOne({_id: uid}, {stripecustomerid: null})
			.catch((err)=>{console.warn(`Failed to unmark pending purchase: ${err}`)})
			
			//Customers are only used to charge, but obviously cant charge since cant create subscription, so delete their customer
			await stripe.customers.del(
				customer.id,
				function(err, confirmation) {
					if(err) console.warn("Failed to delete a Stripe customer:", err);
				}
			);
			
			//Tell them why the charge failed. This is safe according to Stripe
			throw err.message
		})

		//At this point, the charge was successfully requested. The webhook will handle confirmation of purchase
		response.success = true
		res.json(response)
	} 
	catch(e) {
		next(e)
	}
})

router.use('/cancel', bodyParser.urlencoded({ extended: false }))
router.use('/cancel', bodyParser.json({limit: '5mb'}))
router.post('/cancel', async (req, res, next) => {
	try {
		let response = {success:false}

		let uid = null
		if(req.body.uid) uid = req.body.uid //to support old implementation
		else uid = req.session.uid //for react app implementation. the new way
		if(!uid) throw "Not logged in"
		
		//Fetch account
		let accData = await Accounts.findById(uid)
		if(!accData) throw "Failed to retrieve your account"
		//Check if they have a recorded customer id
		if(!accData.stripecustomerid) throw "Not a recorded customer"
		
		/*
		If they still have stripecustomerid, they are probably still being charged. 
		The webhook should've removed it upon expiration. On that note, its unncessary to
		check if they have the patron role. Good idea to continue anyways incase they're
		missing the patron role for what ever reason(bug, new name, etc).
		*/

		// Retrieve their subscription
		//Gets list of all active subscriptions from Stripe customer
		const subscriptions = (await stripe.subscriptions.list({customer: accData.stripecustomerid})).data
		if(subscriptions.length <= 0) throw "You do not have a subscription"
		//Users should only have 1 subscription. Its a bug if they have multiple, so warn dev
		if(subscriptions.length > 1) console.warn(`${req.session.uid} has multiple active subscriptions`)

		await stripe.subscriptions.update(subscriptions[0].id, { cancel_at_period_end: true })

		//Subscription marked for cancellation at end period
		response.success = true
				
		//Reflect in database as well
		accData.pendingcancellation = "stripe"
		await accData.save()
		.catch(err=> console.log(`Failed to reflect Stripe cancellation onto ${uid}'s account.`))

		res.json(response)
	} 
	catch(e){
		next(e)
	}
})

router.use('/uncancel', bodyParser.urlencoded({ extended: false }))
router.use('/uncancel', bodyParser.json({limit: '5mb'}))
router.post('/uncancel', async (req, res, next) => {
	try {
		let response = {success:false}

		if(!req.session.uid) throw "Not logged in"

		//Fetch account
		let accData = await Accounts.findById(req.session.uid)
		if(!accData) throw "Failed to retrieve your account"
		//Check if they have a recorded customer id
		if(!accData.stripecustomerid) throw "Not a recorded customer"
		
		// Retrieve their subscription
		//Gets list of all active subscriptions from Stripe customer
		const subscriptions = (await stripe.subscriptions.list({customer: accData.stripecustomerid})).data
		if(subscriptions.length <= 0) throw "You do not have a subscription"
		//Users should only have 1 subscription. Its a bug if they have multiple, so warn dev
		if(subscriptions.length > 1) console.warn(`${req.session.uid} has multiple active subscriptions`)

		await stripe.subscriptions.update(subscriptions[0].id, { cancel_at_period_end: false })

		//Reflect in database as well
		accData.pendingcancellation = null
		await accData.save()

		//Subscription marked for cancellation at end period
		response.success = true
		res.json(response)
	}
	catch(e){
		next(e)
	}
})

//Webhook. Stripe calls to this point. A call to this is never from the forum
router.use('/webhook', bodyParser.raw({type: '*/*'}))
router.post('/webhook', async (req, res) => {
	let sig = req.headers["stripe-signature"];
	let event

	let forumTitle = (await ForumSettings.findOne({type: "name"})).value

	try {
		event = stripe.webhooks.constructEvent(req.body, sig, webhookSecret);
		var base = event.data.object

		//Get the Stripe customer
		var customerID
		if(base.object === "customer") customerID = base.id
		else customerID = base.customer
		var customer = await stripe.customers.retrieve(customerID)

		//Fetch their account ID
		var uid = customer.metadata ? customer.metadata.uid : "??"
		console.log(`Stripe Webhook: ${event.type} for uid: ${uid}`)

		//Some event types like "customer.deleted" can't be handled since event.data.object.customer doesn't exist
		switch(event.type){
			//Subscription paid
			case "invoice.payment_succeeded":
				{
					var acc = await Accounts.findById(uid).lean()
					if(!acc) throw new Error("Account doesn't exist for uid: " + uid)

					//User has successfully been charged, so apply the Patron role if necessary
					acc.roles = other.StringToArray(acc.roles)
					if(acc.roles.indexOf("patron") === -1) acc.roles.push('patron')

					//Updates the account in the database to reflect data
					await Accounts.updateOne({_id: uid}, {stripecustomerid: customer.id, roles: JSON.stringify(acc.roles)})
					//Hopefully this will never catch, but here jic I tweak the database layout one day and mess this up
					.catch((err)=>{
						console.log(`!IMPORTANT! Stripe error: Successful payment, but failed to add patron role to uid ${acc.uid}: ${err}`)
						throw `Successful payment, but failed to apply benefits due to server error. Please email ${process.env.SUPPORT_EMAIL_ADDRESS} saying, "My user id is:  ${acc.uid}. The server has reported an error after successfuly purchasing Junior. I did not receive the Junior benefits."`
					})

					//Send thank you email
					let emailBody = 
					`Premium Membership Enrollment - ${forumTitle} \n` +
					'\n' +
					'Payment received. Thank you so much for giving us your support! Seriously, it is very appreciated. Your support comes with benefits during your term. You can find a list of patron benefits at: \n' +
					process.env.FORUM_URL + '/upgrade \n' +
					'\n' +
					'Please note that benefits are subject to change. Especially with the intent of adding more benefits. You will be billed at $5 USD monthly.  \n' +
					'\n' +
					'\n' +
					'Email intended for: \n' +
					`Email: ${acc.email} . \n` +
					`Username: ${acc.username} \n` +
					`User ID: ${uid} \n`
					await mailgun.SendBasicEmail(acc.email, `Payment Confirmation - ${forumTitle}`, emailBody)
				}
				break;
			case "invoice.payment_failed": {
				var acc = await Accounts.findById(uid)
				if(!acc) throw new Error("Account doesn't exist for uid: " + uid)

				//Updates the account in the database to reflect data
				acc.stripecustomerid = null
				acc.pendingcancellation = null
				await acc.save()

				//Inform of failure to pay
				let emailBody = 
				`Payment Failed | ${forumTitle} \n` +
				'\n' +
				'Your payment for your premium membership has failed. Please try again after checking your balance or bank status.\n' +
				'\n' +
				'\n' +
				'Email intended for: \n' +
				`Email: ${acc.email} . \n` +
				`Username: ${acc.username} \n` +
				`User ID: ${acc._id} \n`
				await mailgun.SendBasicEmail(acc.email, `Premium Expired - ${forumTitle}`, emailBody)

				break
			}
			//Subscription ended/expired
			case "customer.subscription.deleted":
				{
					var acc = await Accounts.findById(uid)
					if(!acc) throw new Error("Account doesn't exist for uid: " + uid)
					
					let roles = other.StringToArray(acc.roles)
					
					// Remove patron role
					let index = roles.indexOf("patron")
					if(index != -1){
						roles.splice(index, 1);
					}

					// Give them the VIP role as a token of appreciation
					if(roles.indexOf("vip") === -1){
						roles.push("vip")
					}

					roles = JSON.stringify(roles)
							
					acc.roles = roles
					acc.stripecustomerid = null
					await acc.save()

					// Sorry to see you go email
					let emailBody = 
					`Premium Membership Expired | ${forumTitle} \n` +
					'\n' +
					'Your premium membership has expired. You will no longer be billed and your premium benefits have been removed. \n' +
					'We remain thankful for your support, so you get to keep VIP status and its perks. \n' +
					"\n" +
					`If you would like to upgrade again, you can do so at the upgrade page: ${process.env.FORUM_URL}/upgrade \n` +
					'\n' +
					'\n' +
					'Email intended for: \n' +
					`Email: ${acc.email} . \n` +
					`Username: ${acc.username} \n` +
					`User ID: ${uid} \n`
					//Sends
					await mailgun.SendBasicEmail(acc.email, `Premium Expired - ${forumTitle}`, emailBody)
				}
				break;
			//Subscription updated
			//Most likely canceled or uncanceled their subscription
			case "customer.subscription.updated":
				{
					let cancel_at_period_end = base.cancel_at_period_end ? "stripe" : null

					//Reflect un/cancelation on databse
					await Accounts.updateOne({_id: uid}, {pendingcancellation: cancel_at_period_end})
				}
				break;
			case "charge.refunded": {
				var acc = await Accounts.findById(uid)
				if(!acc) throw new Error("Account doesn't exist for uid: " + uid)

				// Send notice of refund email
				let emailBody = 
				`Refund for Premium Membership| ${forumTitle} \n` +
				'\n' +
				`A refund is on the way.\n` +
				'Please note that this could take 5-10 days to post.\n' +
				'\n' +
				'\n' +
				'Email intended for: \n' +
				`Email: ${acc.email} . \n` +
				`Username: ${acc.username} \n` +
				`User ID: ${uid} \n`
				//Sends
				await mailgun.SendBasicEmail(acc.email, `Refund On The Way - ${forumTitle}`, emailBody)

				break;
			}
			default:
				//nothing
				break
		}
		
		// Return a response
		res.json({received: true});
	}
	catch (e) {
		//The server has errored... Report 400 so Stripe can keep retrying
		//While PayPal retries, this gives me the opportunity to fix the server error
		//Once the server error is fixed, PayPal will eventually call again to give the account benefits
		console.log("Stripe Webhook error-", {event}, "- Error:", e)
		res.status(400).send("Server error")
	}
});

module.exports = router;